[
  {
    "chunk_id": "fast_mcp_api_python:python-sdk:Low-Level_Server_Implementation:chunk:0",
    "content": "This document covers the low-level\n```\nServer\n```\nclass that provides direct access to the MCP protocol implementation. This is the foundation layer that handles raw MCP requests and notifications with minimal abstraction. For high-level server development using decorators and automatic schema generation, see\n[FastMCP Server Framework](#2)\n. For details on session management and client connections, see\n[ServerSession Implementation](#6.2)\n.",
    "metadata": {
      "source": "python-sdk\\Low-Level_Server_Implementation.md",
      "file_name": "Low-Level_Server_Implementation.md",
      "subfolder": "python-sdk",
      "chunk_index": 0,
      "total_chunks": 7,
      "char_count": 444,
      "collection": "fast_mcp_api_python",
      "processing_method": "hybrid_chunker",
      "timestamp": "2025-10-15T07:13:21.252278"
    }
  },
  {
    "chunk_id": "fast_mcp_api_python:python-sdk:Low-Level_Server_Implementation:chunk:1",
    "content": "The\n```\nServer\n```\nclass in\n[src/mcp/server/lowlevel/server.py](.)\nprovides a decorator-based framework for implementing MCP servers with direct control over protocol message handling. Unlike FastMCP's automatic introspection, the low-level server requires explicit handler registration and manual schema definition.\n```\ngraph TB\n    subgraph \"Server Class Structure\"\n        Server[\"Server[LifespanResultT, RequestT]\"]\n        RequestHandlers[\"request_handlers: dict[type, Callable]\"]\n        NotificationHandlers[\"notification_handlers: dict[type, Callable]\"]\n        ToolCache[\"_tool_cache: dict[str, Tool]\"]\n        Lifespan[\"lifespan: AsyncContextManager\"]\n    end\n    \n    subgraph \"Handler Decorators\"\n        ListPrompts[\"@server.list_prompts()\"]\n        GetPrompt[\"@server.get_prompt()\"]\n        ListResources[\"@server.list_resources()\"]\n        ReadResource[\"@server.read_resource()\"]\n        ListTools[\"@server.list_tools()\"]\n        CallTool[\"@server.call_tool()\"]\n        Progress[\"@server.progress_notification()\"]\n    end\n    \n    subgraph \"Protocol Types\"\n        ListPromptsRequest[\"types.ListPromptsRequest\"]\n        GetPromptRequest[\"types.GetPromptRequest\"]\n        ListResourcesRequest[\"types.ListResourcesRequest\"]\n        ReadResourceRequest[\"types.ReadResourceRequest\"]\n        ListToolsRequest[\"types.ListToolsRequest\"]\n        CallToolRequest[\"types.CallToolRequest\"]\n        ProgressNotification[\"types.ProgressNotification\"]\n    end\n    \n    Server --> RequestHandlers\n    Server --> NotificationHandlers\n    Server --> ToolCache\n    Server --> Lifespan\n    \n    ListPrompts --> ListPromptsRequest\n    GetPrompt --> GetPromptRequest\n    ListResources --> ListResourcesRequest\n    ReadResource --> ReadResourceRequest\n    ListTools --> ListToolsRequest\n    CallTool --> CallToolRequest\n    Progress --> ProgressNotification\n    \n    RequestHandlers --> ListPromptsRequest\n    RequestHandlers --> GetPromptRequest\n    RequestHandlers --> ListResourcesRequest\n    RequestHandlers --> ReadResourceRequest\n    RequestHandlers --> ListToolsRequest\n    RequestHandlers --> CallToolRequest\n    NotificationHandlers --> ProgressNotification\n```\nSources:\n[src/mcp/server/lowlevel/server.py:133-158](.)\n,\n[src/mcp/server/lowlevel/server.py:152-155](.)\n,\n[src/mcp/types.py:82-103](.)\nThe\n```\nServer\n```\nclass is generic over two type parameters:\n```\nLifespanResultT\n```\nfor lifespan context data and\n```\nRequestT\n```\nfor request-specific data. It maintains separate dictionaries for request handlers and notification handlers, automatically routing incoming messages based on their type.",
    "metadata": {
      "source": "python-sdk\\Low-Level_Server_Implementation.md",
      "file_name": "Low-Level_Server_Implementation.md",
      "subfolder": "python-sdk",
      "chunk_index": 1,
      "total_chunks": 7,
      "char_count": 2603,
      "collection": "fast_mcp_api_python",
      "processing_method": "hybrid_chunker",
      "timestamp": "2025-10-15T07:13:21.252294"
    }
  },
  {
    "chunk_id": "fast_mcp_api_python:python-sdk:Low-Level_Server_Implementation:chunk:2",
    "content": "Request and notification handlers are registered using decorator methods that map protocol message types to handler functions. Each decorator enforces specific function signatures while providing flexibility in implementation.\n```\ngraph LR\n    subgraph \"Request Handler Registration\"\n        Decorator[\"@server.list_tools()\"]\n        HandlerFunc[\"async def handle_list_tools()\"]\n        RequestType[\"types.ListToolsRequest\"]\n        ResultType[\"types.ListToolsResult\"]\n    end\n    \n    subgraph \"Handler Registry\"\n        RequestHandlers[\"request_handlers[types.ListToolsRequest]\"]\n        Wrapper[\"create_call_wrapper()\"]\n    end\n    \n    subgraph \"Message Processing\"\n        IncomingMessage[\"Incoming ListToolsRequest\"]\n        HandlerLookup[\"handler = request_handlers.get(type(req))\"]\n        HandlerCall[\"await handler(req)\"]\n        ResponseSend[\"await message.respond(response)\"]\n    end\n    \n    Decorator --> HandlerFunc\n    HandlerFunc --> Wrapper\n    Wrapper --> RequestHandlers\n    \n    IncomingMessage --> HandlerLookup\n    HandlerLookup --> RequestHandlers\n    RequestHandlers --> HandlerCall\n    HandlerCall --> ResponseSend\n```\nSources:\n[src/mcp/server/lowlevel/server.py:409-438](.)\n,\n[src/mcp/server/lowlevel/server.py:245-255](.)\n,\n[src/mcp/server/lowlevel/func_inspection.py](.)\nHandler functions can return either the specific result type (e.g.,\n```\nListToolsResult\n```\n) or the legacy format (e.g.,\n```\nlist[Tool]\n```\n). The server automatically wraps legacy returns in the appropriate result container for backward compatibility.",
    "metadata": {
      "source": "python-sdk\\Low-Level_Server_Implementation.md",
      "file_name": "Low-Level_Server_Implementation.md",
      "subfolder": "python-sdk",
      "chunk_index": 2,
      "total_chunks": 7,
      "char_count": 1553,
      "collection": "fast_mcp_api_python",
      "processing_method": "hybrid_chunker",
      "timestamp": "2025-10-15T07:13:21.252301"
    }
  },
  {
    "chunk_id": "fast_mcp_api_python:python-sdk:Low-Level_Server_Implementation:chunk:3",
    "content": "The server implements sophisticated tool management including input/output validation and result processing. Tools are cached to avoid repeated calls to\n```\nlist_tools()\n```\nand support both structured and unstructured content output.\n```\n_tool_cache: dict[str, Tool]\n```\n```\njsonschema.validate()\n```\n```\ninputSchema\n```\n```\njsonschema.validate()\n```\n```\noutputSchema\n```\n```\nCombinationContent\n```\nTool Caching, Implementation = . Tool Caching, Purpose = \n```\ngraph TB\n    subgraph \"Tool Call Processing Flow\"\n        CallRequest[\"CallToolRequest\"]\n        CacheCheck[\"_get_cached_tool_definition()\"]\n        InputValidation[\"jsonschema.validate(arguments, inputSchema)\"]\n        ToolExecution[\"await func(tool_name, arguments)\"]\n        OutputNormalization[\"Normalize results to UnstructuredContent + StructuredContent\"]\n        OutputValidation[\"jsonschema.validate(structuredContent, outputSchema)\"]\n        ResultCreation[\"types.CallToolResult\"]\n    end\n    \n    subgraph \"Content Types\"\n        UnstructuredContent[\"UnstructuredContent: Iterable[ContentBlock]\"]\n        StructuredContent[\"StructuredContent: dict[str, Any]\"]\n        CombinationContent[\"CombinationContent: tuple[Unstructured, Structured]\"]\n    end\n    \n    CallRequest --> CacheCheck\n    CacheCheck --> InputValidation\n    InputValidation --> ToolExecution\n    ToolExecution --> OutputNormalization\n    OutputNormalization --> OutputValidation\n    OutputValidation --> ResultCreation\n    \n    OutputNormalization --> UnstructuredContent\n    OutputNormalization --> StructuredContent\n    ToolExecution --> CombinationContent\n```\nSources:\n[src/mcp/server/lowlevel/server.py:465-547](.)\n,\n[src/mcp/server/lowlevel/server.py:99-102](.)\n,\n[src/mcp/server/lowlevel/server.py:449-463](.)\nThe\n```\ncall_tool()\n```\ndecorator accepts a\n```\nvalidate_input\n```\nparameter to control input validation. Output validation is automatically performed when\n```\noutputSchema\n```\nis defined in the tool definition.",
    "metadata": {
      "source": "python-sdk\\Low-Level_Server_Implementation.md",
      "file_name": "Low-Level_Server_Implementation.md",
      "subfolder": "python-sdk",
      "chunk_index": 3,
      "total_chunks": 7,
      "char_count": 1966,
      "collection": "fast_mcp_api_python",
      "processing_method": "hybrid_chunker",
      "timestamp": "2025-10-15T07:13:21.252306"
    }
  },
  {
    "chunk_id": "fast_mcp_api_python:python-sdk:Low-Level_Server_Implementation:chunk:4",
    "content": "The server uses Python's\n```\ncontextvars\n```\nmodule to provide request-scoped context accessible throughout the handler call stack. This context includes session information, lifespan data, and request metadata.\n```\ngraph TB\n    subgraph \"Context Management\"\n        ContextVar[\"request_ctx: ContextVar[RequestContext]\"]\n        RequestContext[\"RequestContext[ServerSession, LifespanResultT, RequestT]\"]\n        RequestProperty[\"server.request_context\"]\n    end\n    \n    subgraph \"Context Content\"\n        RequestId[\"request_id: str\"]\n        RequestMeta[\"request_meta: dict\"]\n        Session[\"session: ServerSession\"]\n        LifespanContext[\"lifespan_context: LifespanResultT\"]\n        RequestData[\"request: RequestT\"]\n    end\n    \n    subgraph \"Context Lifecycle\"\n        SetContext[\"token = request_ctx.set(context)\"]\n        HandlerExecution[\"await handler(req)\"]\n        ResetContext[\"request_ctx.reset(token)\"]\n    end\n    \n    ContextVar --> RequestContext\n    RequestContext --> RequestProperty\n    \n    RequestContext --> RequestId\n    RequestContext --> RequestMeta\n    RequestContext --> Session\n    RequestContext --> LifespanContext\n    RequestContext --> RequestData\n    \n    SetContext --> HandlerExecution\n    HandlerExecution --> ResetContext\n```\nSources:\n[src/mcp/server/lowlevel/server.py:105](.)\n,\n[src/mcp/server/lowlevel/server.py:232-236](.)\n,\n[src/mcp/server/lowlevel/server.py:677-685](.)\n,\n[src/mcp/shared/context.py](.)",
    "metadata": {
      "source": "python-sdk\\Low-Level_Server_Implementation.md",
      "file_name": "Low-Level_Server_Implementation.md",
      "subfolder": "python-sdk",
      "chunk_index": 4,
      "total_chunks": 7,
      "char_count": 1447,
      "collection": "fast_mcp_api_python",
      "processing_method": "hybrid_chunker",
      "timestamp": "2025-10-15T07:13:21.252312"
    }
  },
  {
    "chunk_id": "fast_mcp_api_python:python-sdk:Low-Level_Server_Implementation:chunk:5",
    "content": "The server's main\n```\nrun()\n```\nmethod establishes a session and processes incoming messages through a task group, ensuring proper error handling and response delivery.\n```\ngraph TB\n    subgraph \"Server Run Loop\"\n        AsyncExitStack[\"AsyncExitStack\"]\n        LifespanEntry[\"lifespan_context = await stack.enter_async_context(self.lifespan)\"]\n        SessionEntry[\"session = await stack.enter_async_context(ServerSession)\"]\n        TaskGroup[\"anyio.create_task_group()\"]\n        MessageLoop[\"async for message in session.incoming_messages\"]\n        TaskSpawn[\"tg.start_soon(_handle_message)\"]\n    end\n    \n    subgraph \"Message Handling\"\n        HandleMessage[\"_handle_message()\"]\n        MessageType{\"isinstance(message, RequestResponder)\"}\n        HandleRequest[\"_handle_request()\"]\n        HandleNotification[\"_handle_notification()\"]\n    end\n    \n    subgraph \"Request Processing\"\n        HandlerLookup[\"handler = request_handlers.get(type(req))\"]\n        ContextSetup[\"request_ctx.set(RequestContext)\"]\n        HandlerCall[\"response = await handler(req)\"]\n        ResponseSend[\"await message.respond(response)\"]\n        ContextCleanup[\"request_ctx.reset(token)\"]\n    end\n    \n    AsyncExitStack --> LifespanEntry\n    LifespanEntry --> SessionEntry\n    SessionEntry --> TaskGroup\n    TaskGroup --> MessageLoop\n    MessageLoop --> TaskSpawn\n    TaskSpawn --> HandleMessage\n    \n    HandleMessage --> MessageType\n    MessageType -->|RequestResponder| HandleRequest\n    MessageType -->|Notification| HandleNotification\n    \n    HandleRequest --> HandlerLookup\n    HandlerLookup --> ContextSetup\n    ContextSetup --> HandlerCall\n    HandlerCall --> ResponseSend\n    ResponseSend --> ContextCleanup\n```\nSources:\n[src/mcp/server/lowlevel/server.py:598-636](.)\n,\n[src/mcp/server/lowlevel/server.py:637-655](.)\n,\n[src/mcp/server/lowlevel/server.py:656-713](.)",
    "metadata": {
      "source": "python-sdk\\Low-Level_Server_Implementation.md",
      "file_name": "Low-Level_Server_Implementation.md",
      "subfolder": "python-sdk",
      "chunk_index": 5,
      "total_chunks": 7,
      "char_count": 1857,
      "collection": "fast_mcp_api_python",
      "processing_method": "hybrid_chunker",
      "timestamp": "2025-10-15T07:13:21.252318"
    }
  },
  {
    "chunk_id": "fast_mcp_api_python:python-sdk:Low-Level_Server_Implementation:chunk:6",
    "content": "The server automatically generates\n```\nServerCapabilities\n```\nbased on registered handlers, allowing clients to discover available functionality without manual configuration.\n```\ngraph LR\n    subgraph \"Handler Registration\"\n        ListPromptsHandler[\"types.ListPromptsRequest in request_handlers\"]\n        ListResourcesHandler[\"types.ListResourcesRequest in request_handlers\"]\n        ListToolsHandler[\"types.ListToolsRequest in request_handlers\"]\n        SetLevelHandler[\"types.SetLevelRequest in request_handlers\"]\n        CompleteHandler[\"types.CompleteRequest in request_handlers\"]\n    end\n    \n    subgraph \"Generated Capabilities\"\n        PromptsCapability[\"PromptsCapability(listChanged=...)\"]\n        ResourcesCapability[\"ResourcesCapability(subscribe=False, listChanged=...)\"]\n        ToolsCapability[\"ToolsCapability(listChanged=...)\"]\n        LoggingCapability[\"LoggingCapability()\"]\n        CompletionsCapability[\"CompletionsCapability()\"]\n    end\n    \n    subgraph \"ServerCapabilities\"\n        ServerCaps[\"ServerCapabilities\"]\n    end\n    \n    ListPromptsHandler --> PromptsCapability\n    ListResourcesHandler --> ResourcesCapability\n    ListToolsHandler --> ToolsCapability\n    SetLevelHandler --> LoggingCapability\n    CompleteHandler --> CompletionsCapability\n    \n    PromptsCapability --> ServerCaps\n    ResourcesCapability --> ServerCaps\n    ToolsCapability --> ServerCaps\n    LoggingCapability --> ServerCaps\n    CompletionsCapability --> ServerCaps\n```\nSources:\n[src/mcp/server/lowlevel/server.py:188-229](.)\n,\n[src/mcp/types.py:317-332](.)\n,\n[src/mcp/server/lowlevel/server.py:159-186](.)\nThe\n```\nNotificationOptions\n```\nclass controls whether the server supports change notifications for prompts, resources, and tools, which are reflected in the generated capabilities.",
    "metadata": {
      "source": "python-sdk\\Low-Level_Server_Implementation.md",
      "file_name": "Low-Level_Server_Implementation.md",
      "subfolder": "python-sdk",
      "chunk_index": 6,
      "total_chunks": 7,
      "char_count": 1793,
      "collection": "fast_mcp_api_python",
      "processing_method": "hybrid_chunker",
      "timestamp": "2025-10-15T07:13:21.252323"
    }
  }
]