{
  "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
  "title": "#### On this page",
  "num_chunks": 6,
  "total_chars": 4487,
  "chunks": [
    {
      "index": 0,
      "text": "On this page\n- [Pydantic](\\docs\\reference\\python\\guides\\pydantic#pydantic)\n- [Step output](\\docs\\reference\\python\\guides\\pydantic#step-output)\n- [Function output](\\docs\\reference\\python\\guides\\pydantic#function-output)\n- [Sending events](\\docs\\reference\\python\\guides\\pydantic#sending-events)\n- [Receiving events](\\docs\\reference\\python\\guides\\pydantic#receiving-events)\nReferences\n[Python SDK](\\docs\\reference\\python)\n[Guides](\\docs\\reference\\python\\guides\\testing)",
      "char_count": 466,
      "token_count": 147,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "file_name": "reference_python_guides_pydantic.md",
        "file_size": 4823,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "312c14ede7569a05315c53b94081e1256e9e9e4923ae2e467b46709649db6e86",
        "author": null,
        "created_at": "2025-10-13T00:00:57.916707",
        "modified_at": "2025-10-13T00:00:57.916837",
        "page_count": null,
        "word_count": 704,
        "extracted_at": "2025-10-13T20:04:40.522496",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 6,
        "token_count": 147,
        "has_context": true
      }
    },
    {
      "index": 1,
      "text": "Pydantic\nThis guide will help you use Pydantic to perform runtime type validation when sending and receiving events.",
      "char_count": 116,
      "token_count": 24,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "file_name": "reference_python_guides_pydantic.md",
        "file_size": 4823,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "312c14ede7569a05315c53b94081e1256e9e9e4923ae2e467b46709649db6e86",
        "author": null,
        "created_at": "2025-10-13T00:00:57.916707",
        "modified_at": "2025-10-13T00:00:57.916837",
        "page_count": null,
        "word_count": 704,
        "extracted_at": "2025-10-13T20:04:40.522496",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 6,
        "token_count": 24,
        "has_context": true
      }
    },
    {
      "index": 2,
      "text": "Pydantic\nStep output\nSteps can return Pydantic objects as long as the\n```\noutput_type\n```\nparameter is set to the Pydantic model return type.\nCopy Copied\n```\nclient = inngest . Inngest (\napp_id = \"my-app\" ,\n\n# Must set the client serializer when using Pydantic output\nserializer = inngest. PydanticSerializer (),\n)\n\nclass User ( pydantic . BaseModel ):\nname : str\n\nasync def get_user () -> User:\nreturn User (name = \"Alice\" )\n\n@client . create_function (\nfn_id = \"my-fn\" ,\ntrigger = inngest. TriggerEvent (event = \"my-event\" ),\n)\nasync def my_fn ( ctx : inngest . Context) -> None :\n# user object is a Pydantic object at both runtime and compile time\nuser = await ctx . step . run ( \"get-user\" , get_user, output_type = User)\n```\nMore complex types work as well. For example, if the\n```\nget_user\n```\nfunction returned an\n```\nlist[Admin | User]\n```\ntype, you could set the\n```\noutput_type\n```\nto\n```\nlist[Admin | User]\n```\n.\nCopy Copied\n```\nawait ctx . step . run ( \"get-person\" , get_users, output_type = list[User | Admin])\n```\nWhy do I need to set the\n```\noutput_type\n```\nparameter?\nSince step output is transmitted as JSON back to the Inngest server, we lose the reference to the original Python class. So the\n```\noutput_type\n```\nparameter is used to deserialize the JSON back into the correct type.\nWhy can't the SDK infer the output type from my type annotations?\nThe could sometimes work, but there are common patterns that break it. Runtime return type inference is impossible if the return type:\n- Is implicit (i.e. not specified but your type checker figures it out).\n- Is a generic.",
      "char_count": 1592,
      "token_count": 424,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "file_name": "reference_python_guides_pydantic.md",
        "file_size": 4823,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "312c14ede7569a05315c53b94081e1256e9e9e4923ae2e467b46709649db6e86",
        "author": null,
        "created_at": "2025-10-13T00:00:57.916707",
        "modified_at": "2025-10-13T00:00:57.916837",
        "page_count": null,
        "word_count": 704,
        "extracted_at": "2025-10-13T20:04:40.522496",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 6,
        "token_count": 424,
        "has_context": true
      }
    },
    {
      "index": 3,
      "text": "Pydantic\nFunction output\nFunctions can return Pydantic objects as long as the\n```\noutput_type\n```\nparameter is set to the Pydantic model return type.\nCopy Copied\n```\nclient = inngest . Inngest (\napp_id = \"my-app\" ,\n\n# Must set the client serializer when using Pydantic output\nserializer = inngest. PydanticSerializer (),\n)\n\nclass User ( pydantic . BaseModel ):\nname : str\n\n@client . create_function (\nfn_id = \"my-fn\" ,\noutput_type = User,\ntrigger = inngest. TriggerEvent (event = \"my-event\" ),\n)\nasync def my_fn ( ctx : inngest . Context) -> None :\nreturn User (name = \"Alice\" )\n```",
      "char_count": 582,
      "token_count": 163,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "file_name": "reference_python_guides_pydantic.md",
        "file_size": 4823,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "312c14ede7569a05315c53b94081e1256e9e9e4923ae2e467b46709649db6e86",
        "author": null,
        "created_at": "2025-10-13T00:00:57.916707",
        "modified_at": "2025-10-13T00:00:57.916837",
        "page_count": null,
        "word_count": 704,
        "extracted_at": "2025-10-13T20:04:40.522496",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 6,
        "token_count": 163,
        "has_context": true
      }
    },
    {
      "index": 4,
      "text": "Pydantic\nSending events\nCreate a base class that all your event classes will inherit from. This class has methods to convert to and from\n```\ninngest.Event\n```\nobjects.\nCopy Copied\n```\nimport inngest\nimport pydantic\nimport typing\n\nTEvent = typing . TypeVar ( \"TEvent\" , bound = \"BaseEvent\" )\n\nclass BaseEvent ( pydantic . BaseModel ):\ndata : pydantic . BaseModel\nid : str = \"\"\nname : typing . ClassVar [ str ]\nts : int = 0\n\n@ classmethod\ndef from_event ( cls : type [ TEvent ], event : inngest . Event) -> TEvent:\nreturn cls . model_validate (event. model_dump (mode = \"json\" ))\n\ndef to_event ( self ) -> inngest . Event:\nreturn inngest . Event (\nname = self.name,\ndata = self.data. model_dump (mode = \"json\" ),\nid = self.id,\nts = self.ts,\n)\n```\nNext, create a Pydantic model for your event.\nCopy Copied\n```\nclass PostUpvotedEventData ( pydantic . BaseModel ):\ncount : int\n\nclass PostUpvotedEvent ( BaseEvent ):\ndata : PostUpvotedEventData\nname : typing . ClassVar [ str ] = \"forum/post.upvoted\"\n```\nSince Pydantic validates on instantiation, the following code will raise an error if the data is invalid.\nCopy Copied\n```\nclient . send (\nPostUpvotedEvent (\ndata = PostUpvotedEventData (count = \"bad data\" ),\n). to_event ()\n)\n```",
      "char_count": 1227,
      "token_count": 345,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "file_name": "reference_python_guides_pydantic.md",
        "file_size": 4823,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "312c14ede7569a05315c53b94081e1256e9e9e4923ae2e467b46709649db6e86",
        "author": null,
        "created_at": "2025-10-13T00:00:57.916707",
        "modified_at": "2025-10-13T00:00:57.916837",
        "page_count": null,
        "word_count": 704,
        "extracted_at": "2025-10-13T20:04:40.522496",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 6,
        "token_count": 345,
        "has_context": true
      }
    },
    {
      "index": 5,
      "text": "Pydantic\nReceiving events\nWhen defining your Inngest function, use the\n```\nname\n```\nclass field when specifying the trigger. Within the function body, call the\n```\nfrom_event\n```\nclass method to convert the\n```\ninngest.Event\n```\nobject to your Pydantic model.\nCopy Copied\n```\n@client . create_function (\nfn_id = \"handle-upvoted-post\" ,\ntrigger = inngest. TriggerEvent (event = PostUpvotedEvent.name),\n)\ndef fn ( ctx : inngest . ContextSync) -> None :\nevent = PostUpvotedEvent . from_event (ctx.event)\n```",
      "char_count": 504,
      "token_count": 142,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_python_guides_pydantic.md",
        "file_name": "reference_python_guides_pydantic.md",
        "file_size": 4823,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "312c14ede7569a05315c53b94081e1256e9e9e4923ae2e467b46709649db6e86",
        "author": null,
        "created_at": "2025-10-13T00:00:57.916707",
        "modified_at": "2025-10-13T00:00:57.916837",
        "page_count": null,
        "word_count": 704,
        "extracted_at": "2025-10-13T20:04:40.522496",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 6,
        "token_count": 142,
        "has_context": true
      }
    }
  ]
}