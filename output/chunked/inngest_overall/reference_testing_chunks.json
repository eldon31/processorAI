{
  "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
  "title": "#### On this page",
  "num_chunks": 12,
  "total_chars": 9167,
  "chunks": [
    {
      "index": 0,
      "text": "On this page\n- [Testing](\\docs\\reference\\testing#testing)\n- [Installation](\\docs\\reference\\testing#installation)\n- [Unit tests](\\docs\\reference\\testing#unit-tests)\n- [Running an individual step](\\docs\\reference\\testing#running-an-individual-step)\n- [Assertions](\\docs\\reference\\testing#assertions)\n- [Mocking](\\docs\\reference\\testing#mocking)\nReferences\n[TypeScript SDK](\\docs\\reference\\typescript)",
      "char_count": 398,
      "token_count": 109,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 109,
        "has_context": true
      }
    },
    {
      "index": 1,
      "text": "Testing\nTo test your Inngest functions programmatically, use the\n```\n@inngest/test\n```\nlibrary, available on\n[npm](https://www.npmjs.com/package/@inngest/test)\nand\n[JSR](https://jsr.io/@inngest/test)\n.\nThis allows you to mock function state, step tooling, and inputs with a\nJest-compatible API supporting all major testing frameworks, runtimes, and\nlibraries:\n- jest\n- vitest\n- `bun:test` (Bun)\n- `@std/expect` (Deno)\n- `chai` / `expect`",
      "char_count": 437,
      "token_count": 135,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 135,
        "has_context": true
      }
    },
    {
      "index": 2,
      "text": "Testing\nInstallation\nThe\n```\n@inngest/test\n```\npackage requires\n```\ninngest@>=3.22.12\n```\n.\nnpm Yarn pnpm Bun Deno\nCopy Copied\n```\nnpm install -D @inngest/test\n```",
      "char_count": 163,
      "token_count": 63,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 63,
        "has_context": true
      }
    },
    {
      "index": 3,
      "text": "Testing\nUnit tests\nUse whichever supported testing framework;\n```\n@inngest/test\n```\nis unopinionated\nabout how your tests are run. We'll demonstrate here using\n```\njest\n```\n.\nImport\n```\nInngestTestEngine\n```\n, our function to test, and create a new\n```\nInngestTestEngine\n```\ninstance.\nCopy Copied\n```\nimport { InngestTestEngine } from \"@inngest/test\" ;\nimport { helloWorld } from \"./helloWorld\" ;\n\ndescribe ( \"helloWorld function\" , () => {\nconst t = new InngestTestEngine ({\nfunction : helloWorld ,\n});\n});\n```\nNow we can use the primary API for testing,\n```\nt.execute()\n```\n:\nCopy Copied\n```\ntest ( \"returns a greeting\" , async () => {\nconst { result } = await t .execute ();\nexpect (result) .toEqual ( \"Hello World!\" );\n});\n```\nThis will run the entire function (steps and all) to completion, then return the\nresponse from the function, where we assert that it was the string\n```\n\"Hello World!\"\n```\n.\nA serialized\n```\nerror\n```\nwill be returned instead of\n```\nresult\n```\nif the function threw:\nCopy Copied\n```\ntest ( \"throws an error\" , async () => {\nconst { error } = await t .execute ();\nexpect (error) .toContain ( \"Some specific error\" );\n});\n```\nWhen using steps that delay execution, like\n```\nstep.sleep\n```\nor\n```\nstep.waitForEvent\n```\n, you will need to mock them.\n[Learn more about mocking steps](\\docs\\reference\\testing#steps)\n.",
      "char_count": 1341,
      "token_count": 368,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 368,
        "has_context": true
      }
    },
    {
      "index": 4,
      "text": "Testing\nUnit tests\nRunning an individual step\n```\nt.executeStep()\n```\ncan be used to run the function until a particular step has\nbeen executed.\nThis is useful to test a single step within a function or to see that a\nnon-runnable step such as\n```\nstep.waitForEvent()\n```\nhas been registered with the\ncorrect options.\nCopy Copied\n```\ntest ( \"runs the price calculations\" , async () => {\nconst { result } = await t .executeStep ( \"calculate-price\" );\nexpect (result) .toEqual ( 123 );\n});\n```\nAssertions can also be made on steps in any part of a run, regardless of if\nthat's the checkpoint we've waited for. See\n[Assertions -> State](\\docs\\reference\\testing#assertions)\n.",
      "char_count": 670,
      "token_count": 170,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 170,
        "has_context": true
      }
    },
    {
      "index": 5,
      "text": "Testing\nUnit tests\nAssertions\n```\n@inngest/test\n```\nadds Jest-compatible mocks by default that can help you assert\nfunction and step input and output. You can assert:\n- Function input\n- Function output\n- Step output\n- Step tool usage\nAll of these values are returned from both\n```\nt.execute()\n```\nand\n```\nt.executeStep()\n```\n;\nwe'll only show one for simplicity here.\nThe\n```\nresult\n```\nis returned, which is the output of the run or step:\nCopy Copied\n```\nconst { result } = await t .execute ();\nexpect (result) .toEqual ( \"Hello World!\" );\n```\n```\nctx\n```\nis the input used for the function run. This can be used to assert outputs\nthat are based on input data such as\n```\nevent\n```\nor\n```\nrunId\n```\n, or to confirm that\nmiddleware is working correctly and affecting input arguments.\nCopy Copied\n```\nconst { ctx , result } = await t .execute ();\nexpect (result) .toEqual ( `Run ID was: \" ${ ctx .runId } \"` );\n```\nThe step tooling at\n```\nctx.step\n```\nare all Jest-compatible spy functions, so you can\nuse them to assert that they've been called and used correctly:\nCopy Copied\n```\nconst { ctx } = await t .execute ();\nexpect ( ctx . step .run) .toHaveBeenCalledWith ( \"my-step\" , expect .any (Function));\n```\n```\nstate\n```\nis also returned, which is a view into the outputs of all steps in the\nrun. This allows you to test each individual step output for any given input:\nCopy Copied\n```\nconst { state } = await t .execute ();\nexpect (state[ \"my-step\" ]). resolves .toEqual ( \"some successful output\" );\nexpect (state[ \"dangerous-step\" ]). rejects .toThrowError ( \"something failed\" );\n```",
      "char_count": 1589,
      "token_count": 419,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 419,
        "has_context": true
      }
    },
    {
      "index": 6,
      "text": "Testing\nUnit tests\nMocking\nSome mocking is done automatically by\n```\n@inngest/test\n```\n, but can be overwritten if\nneeded.\nAll mocks detailed below can be specified either when creating an\n```\nInngestTestEngine\n```\ninstance or for each individual execution:\nCopy Copied\n```\n// Set the events for every execution\nconst t = new InngestTestEngine ({\nfunction : helloWorld ,\n// mocks here\n});\n\n// Or for just one, which will overwrite any current event mocks\nt .execute ({\n// mocks here\n});\n\nt .executeStep ( \"my-step\" , {\n// mocks here\n})\n```\nYou can also clone an existing\n```\nInngestTestEngine\n```\ninstance to encourage re-use\nof complex mocks:\nCopy Copied\n```\n// Make a direct clone, which includes any mocks\nconst otherT = t .clone ();\n\n// Provide some more mocks in addition to any existing ones\nconst anotherT = t .clone ({\n// mocks here\n});\n```\nFor simplicity, the following examples will show usage of\n```\nt.execute()\n```\n, but the\nmocks can be placed in any of these locations.",
      "char_count": 983,
      "token_count": 250,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 250,
        "has_context": true
      }
    },
    {
      "index": 7,
      "text": "Testing\nUnit tests\nEvents\nThe incoming event data can be mocked. They are always specified as an array of\nevents to allow also mocking batches.\nCopy Copied\n```\nt .execute ({\nevents : [{ name : \"demo/event.sent\" , data : { message : \"Hi!\" } }] ,\n});\n```\nIf no event mocks are given at all (or\n```\nevents: undefined\n```\nis explicitly set),\nan\n```\ninngest/function.invoked\n```\nevent will be mocked for you.",
      "char_count": 403,
      "token_count": 109,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 109,
        "has_context": true
      }
    },
    {
      "index": 8,
      "text": "Testing\nUnit tests\nSteps\nMocking steps can help you model different paths and situations within your\nfunction. To do so, any step can be mocked by providing the\n```\nsteps\n```\noption. You should always mock\n```\nsleep\n```\nand\n```\nwaitForEvent\n```\nsteps -\n[learn more here](\\docs\\reference\\testing#sleep-and-wait-for-event)\n.\nHere we mock two steps, one that will run successfully and another that will\nmodel a failure and throw an error:\nCopy Copied\n```\nt .execute ({\nsteps : [\n{\nid : \"successful-step\" ,\nhandler () {\nreturn \"We did it!\" ;\n} ,\n} ,\n{\nid : \"dangerous-step\" ,\nhandler () {\nthrow new Error ( \"Oh no!\" );\n} ,\n} ,\n] ,\n});\n```\nThese handlers will run lazily when they are found during a function's execution.\nThis means you can write complex mocks that respond to other information:\nCopy Copied\n```\nlet message = \"\" ;\n\nt .execute ({\nsteps : [\n{\nid : \"build-greeting\" ,\nhandler () {\nmessage = \"Hello, \" ;\nreturn message;\n} ,\n} ,\n{\nid : \"build-name\" ,\nhandler () {\nreturn message + \" World!\" ;\n} ,\n} ,\n] ,\n});\n```",
      "char_count": 1019,
      "token_count": 274,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 274,
        "has_context": true
      }
    },
    {
      "index": 9,
      "text": "Testing\nUnit tests\nSleep and waitForEvent\nSteps that pause the function,\n```\nstep.sleep\n```\n,\n```\nstep.sleepUntil\n```\n, and\n```\nstep.waitForEvent\n```\nshould always be mocked.\nstep.sleep step.waitForEvent\nCopy Copied\n```\n// Given the following function that sleeps\nconst myFunction = inngest .createFunction (\n{ id : \"my-function\" } ,\n{ event : \"user.created\" } ,\nasync ({ event , step }) => {\nawait step .sleep ( \"one-day-delay\" , \"1d\" );\nreturn { message : \"success\" };\n}\n)\n// Mock the step to execute a no-op handler to return immediately\nt .execute ({\nsteps : [\n{\nid : \"one-day-delay\" ,\nhandler () {} , // no return value necessary\n} ,\n] ,\n});\n```",
      "char_count": 650,
      "token_count": 177,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 177,
        "has_context": true
      }
    },
    {
      "index": 10,
      "text": "Testing\nUnit tests\nModules and imports\nAny mocking of modules or imports outside of Inngest which your functions may\nrely on should be done outside of Inngest with the testing framework you're\nusing.\nHere are some links to the major supported frameworks and their guidance for\nmocking imports:\n- [jest](https://jestjs.io/docs/mock-functions#mocking-modules)\n- [vitest](https://vitest.dev/guide/mocking#modules)\n- [`bun:test`](https://bun.sh/docs/test/mocks#module-mocks-with-mock-module) [(Bun)](https://bun.sh/docs/test/mocks#module-mocks-with-mock-module)\n- [`@std/testing`](https://jsr.io/@std/testing/doc/mock/~) [(Deno)](https://jsr.io/@std/testing/doc/mock/~)",
      "char_count": 665,
      "token_count": 179,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 179,
        "has_context": true
      }
    },
    {
      "index": 11,
      "text": "Testing\nUnit tests\nCustom\nYou can also provide your own custom mocks for the function input.\nWhen instantiating a new\n```\nInngestTestEngine\n```\nor starting an execution, provide a\n```\ntransformCtx\n```\nfunction that will add these mocks every time the function is\nrun:\nCopy Copied\n```\nconst t = new InngestTestEngine ({\nfunction : helloWorld ,\ntransformCtx : (ctx) => {\nreturn {\n... ctx ,\nevent : someCustomThing ,\n};\n} ,\n});\n```\nIf you wish to still add the automatic mocking from\n```\n@inngest/test\n```\n(such as the\nspies on\n```\nctx.step.*\n```\n), you can import and use the automatic transforms as part\nof your own:\nCopy Copied\n```\nimport { InngestTestEngine , mockCtx } from \"@inngest/test\" ;\n\nconst t = new InngestTestEngine ({\nfunction : helloWorld ,\ntransformCtx : (ctx) => {\nreturn {\n... mockCtx (ctx) ,\nevent : someCustomThing ,\n};\n} ,\n});\n```",
      "char_count": 849,
      "token_count": 232,
      "metadata": {
        "title": "#### On this page",
        "source": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "chunk_method": "hybrid",
        "file_path": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\Docs\\inngest_overall\\reference_testing.md",
        "file_name": "reference_testing.md",
        "file_size": 9745,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "4301e7e8f613e923b349fe6ff99a2dab70b7c690f2000db2e241c57a47ae2601",
        "author": null,
        "created_at": "2025-10-13T00:01:26.352576",
        "modified_at": "2025-10-13T00:01:26.352576",
        "page_count": null,
        "word_count": 1424,
        "extracted_at": "2025-10-13T20:04:53.468532",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 12,
        "token_count": 232,
        "has_context": true
      }
    }
  ]
}