{
  "source": "Docs\\agent_kit\\concepts_memory.md",
  "title": "##### Get Started",
  "num_chunks": 23,
  "total_chars": 17839,
  "chunks": [
    {
      "index": 0,
      "text": "Get Started\n- [Overview](\\overview)\n- [Quick start](\\getting-started\\quick-start)\n- [Installation](\\getting-started\\installation)\n- [Local development](\\getting-started\\local-development)",
      "char_count": 187,
      "token_count": 47,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 47,
        "has_context": true
      }
    },
    {
      "index": 1,
      "text": "Concepts\n- [Agents](\\concepts\\agents)\n- [Tools](\\concepts\\tools)\n- [Networks](\\concepts\\networks)\n- [State](\\concepts\\state)\n- [Routers](\\concepts\\routers)\n- [History](\\concepts\\history)\n- [Memory](\\concepts\\memory)\n- [Models](\\concepts\\models)\n- [Deployment](\\concepts\\deployment)",
      "char_count": 281,
      "token_count": 95,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 95,
        "has_context": true
      }
    },
    {
      "index": 2,
      "text": "Streaming\n- [Overview](\\streaming\\overview)\n- [Usage Guide](\\streaming\\usage-guide)\n- [Events](\\streaming\\events)\n- [Transport](\\streaming\\transport)\n- [Provider](\\streaming\\provider)",
      "char_count": 183,
      "token_count": 54,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 54,
        "has_context": true
      }
    },
    {
      "index": 3,
      "text": "Advanced Patterns\n- [Deterministic state routing](\\advanced-patterns\\routing)\n- [MCP as tools](\\advanced-patterns\\mcp)\n- [Human in the Loop](\\advanced-patterns\\human-in-the-loop)\n- [Multi-steps tools](\\advanced-patterns\\multi-steps-tools)\n- [Configuring Retries](\\advanced-patterns\\retries)\n- [Configuring Multi-tenancy](\\advanced-patterns\\multitenancy)\n- [UI Streaming with useAgent](\\advanced-patterns\\legacy-ui-streaming)",
      "char_count": 424,
      "token_count": 117,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 117,
        "has_context": true
      }
    },
    {
      "index": 4,
      "text": "Guided Tour\n- [The three levels of AI apps](\\guided-tour\\overview)\n- [1. Explaining a given code file](\\guided-tour\\ai-workflows)\n- [2. Complex code analysis](\\guided-tour\\agentic-workflows)\n- [3. Autonomous Bug Solver](\\guided-tour\\ai-agents)",
      "char_count": 243,
      "token_count": 75,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 75,
        "has_context": true
      }
    },
    {
      "index": 5,
      "text": "Integrations\n- [E2B - Sandboxes for AI Agents](\\integrations\\e2b)\n- [Browserbase - AI Browsers](\\integrations\\browserbase)\n- [Smithery - MCP Registry](\\integrations\\smithery)\nclose\nOn this page\n- [Overview](#overview)\n- [Memory Tools](#memory-tools)\n- [Pattern 1: Granular, Single-Purpose Tools](#pattern-1%3A-granular%2C-single-purpose-tools)\n- [Pattern 2: Consolidated Tools](#pattern-2%3A-consolidated-tools)\n- [Deterministic vs Non-Deterministic Memory](#deterministic-vs-non-deterministic-memory)\n- [Pattern 1: Autonomous Agent with Memory Tools](#pattern-1%3A-autonomous-agent-with-memory-tools)\n- [Example Agent](#example-agent)\n- [Execution Flow](#execution-flow)\n- [Pattern 2: Multi-Agent Network for Memory](#pattern-2%3A-multi-agent-network-for-memory)\n- [Example Agents & Router](#example-agents-%26-router)\n- [Execution Flow](#execution-flow-2)\n- [Advanced Patterns](#advanced-patterns)\n- [State-Based Memory Retrieval / Routing](#state-based-memory-retrieval-%2F-routing)\n- [Lifecycle Integration](#lifecycle-integration)\n- [Complete Example](#complete-example)\nConcepts",
      "char_count": 1084,
      "token_count": 301,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 301,
        "has_context": true
      }
    },
    {
      "index": 6,
      "text": "Memory\nLearn how to give your agents long-term, reflective memory using Mem0.",
      "char_count": 77,
      "token_count": 17,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 17,
        "has_context": true
      }
    },
    {
      "index": 7,
      "text": "Memory\nOverview\nAgentKit allows you to equip your agents with long-term memory, enabling them to recall past interactions, learn user preferences, and maintain context across conversations. By integrating with\n[Mem0](https://docs.mem0.ai/overview)\n, you can build sophisticated agents that offer personalized and context-aware experiences.\nA key advantage of combining Mem0 with AgentKit is the power of Inngest for handling memory operations. When an agent needs to create, update, or delete a memory, it can send an event to Inngest for durable background processing. This means:",
      "char_count": 581,
      "token_count": 118,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 118,
        "has_context": true
      }
    },
    {
      "index": 8,
      "text": "Memory\nFaster Responses\nYour agent can respond to the user immediately, without waiting for database\nwrites to complete.",
      "char_count": 120,
      "token_count": 24,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 24,
        "has_context": true
      }
    },
    {
      "index": 9,
      "text": "Memory\nDurable Background Processing\nThe memory operation runs reliably in the background as a separate, durable\nInngest function. If it fails, Inngest automatically retries it.",
      "char_count": 177,
      "token_count": 37,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 37,
        "has_context": true
      }
    },
    {
      "index": 10,
      "text": "Memory\nMemory Tools\nTo empower your agent with memory, you need to provide it with tools. How you design these tools can significantly impact your agent's behavior, performance, and reliability. AgentKit supports multiple patterns for memory tools, allowing you to choose the best fit for your use case.\nThe core idea is to abstract memory operations (create, read, update, delete) into tools that an agent can call. These tools can then use Inngest to perform the actual database writes asynchronously, ensuring the agent remains responsive.\nCopy Ask AI\n```\n// From examples/mem0-memory/memory-tools.ts\n\nconst createMemoriesTool = createTool ({\nname: \"create_memories\" ,\ndescription: \"Save one or more new pieces of information to memory.\" ,\nparameters: z . object ({\nstatements: z\n. array ( z . string ())\n. describe ( \"The pieces of information to memorize.\" ),\n}),\nhandler : async ({ statements }, { step }) => {\n// 1. Send an event to an Inngest function for background processing\nawait step ?. sendEvent ( \"send-create-memories-event\" , {\nname: \"app/memories.create\" ,\ndata: {\nstatements ,\n},\n});\n// 2. Return immediately to the user\nreturn `I have scheduled the creation of ${ statements . length } new memories.` ;\n},\n});\n\n// A separate Inngest function handles the event\nconst addMemoriesFn = inngest . createFunction (\n{ id: \"add-memories\" },\n{ event: \"app/memories.create\" },\nasync ({ event }) => {\n// 3. Perform the durable memory operation\nconst { statements } = event . data ;\nawait mem0 . add ( statements . map (( s ) => ({ role: \"user\" , content: s })));\nreturn { status: `Added ${ statements . length } memories.` };\n}\n);\n```\nLet's explore two common patterns for designing and integrating these tools into agents.",
      "char_count": 1732,
      "token_count": 404,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 404,
        "has_context": true
      }
    },
    {
      "index": 11,
      "text": "Memory\nMemory Tools\nPattern 1: Granular, Single-Purpose Tools\nThis pattern involves creating a distinct tool for each memory operation:\n- `create_memories` : Adds new information.\n- `recall_memories` : Retrieves existing information.\n- `update_memories` : Corrects or changes existing information.\n- `delete_memories` : Removes information.\nThis gives the agent fine-grained control, but requires it to make more decisions and more tool calls.\nHere's how you might define the\n```\nrecall_memories\n```\nand\n```\ncreate_memories\n```\ntools:\nCopy Ask AI\n```\n// From examples/voice-assistant/tools/memory.ts\n\nconst recallMemoriesTool = createTool ({\nname: \"recall_memories\" ,\ndescription: `Recall memories relevant to one or more queries. Can run multiple queries in parallel.` ,\nparameters: z . object ({\nqueries: z\n. array ( z . string ())\n. describe (\n`The questions to ask your memory to find relevant information.`\n),\n}),\nhandler : async ({ queries }, { step , network }) => {\n// ... implementation to search memories ...\n},\n});\n\nconst createMemoriesTool = createTool ({\nname: \"create_memories\" ,\ndescription: \"Save one or more new pieces of information to memory.\" ,\nparameters: z . object ({\nstatements: z\n. array ( z . string ())\n. describe ( \"The pieces of information to memorize.\" ),\n}),\nhandler : async ({ statements }, { step }) => {\nawait step ?. sendEvent ( \"send-create-memories-event\" , {\nname: \"app/memories.create\" ,\ndata: { statements },\n});\nreturn `I have scheduled the creation of ${ statements . length } new memories.` ;\n},\n});\n```\nThis approach is used in the\n**Autonomous Agent**\npattern described below, where a single, powerful LLM is prompted to reason about which of the specific tools to use at each turn.",
      "char_count": 1728,
      "token_count": 402,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 402,
        "has_context": true
      }
    },
    {
      "index": 12,
      "text": "Memory\nMemory Tools\nPattern 2: Consolidated Tools\nThis pattern simplifies the agent's job by consolidating write operations into a single tool.\n- `recall_memories` : Same as above, for reading.\n- `manage_memories` : A single tool that handles creating, updating, *and* deleting memories in one atomic action.\nThis reduces the number of tools the agent needs to know about and can make its behavior more predictable. It's particularly effective in structured, multi-agent workflows.\nThe\n```\nmanage_memories\n```\ntool can accept lists of creations, updates, and deletions, and then send corresponding events to Inngest.\nCopy Ask AI\n```\n// From examples/voice-assistant/tools/memory.ts\n\nconst manageMemoriesTool = createTool ({\nname: \"manage_memories\" ,\ndescription: `Create, update, and/or delete memories in a single atomic operation. This is the preferred way to modify memories.` ,\nparameters: z . object ({\ncreations: z\n. array ( z . string ())\n. optional ()\n. describe ( \"A list of new statements to save as memories.\" ),\nupdates: z\n. array (\nz . object ({\nid: z . string (). describe ( \"The unique ID of the memory to update.\" ),\nstatement: z\n. string ()\n. describe ( \"The new, corrected information to save.\" ),\n})\n)\n. optional ()\n. describe ( \"A list of memories to update.\" ),\ndeletions: z\n. array (\nz . object ({\nid: z . string (). describe ( \"The unique ID of the memory to delete.\" ),\n})\n)\n. optional ()\n. describe ( \"A list of memories to delete.\" ),\n}),\nhandler : async ({ creations , updates , deletions }, { step }) => {\n// Send events to Inngest for background processing\nif ( creations ?. length ) {\nawait step ?. sendEvent ( \"create-memories\" , {\nname: \"app/memories.create\" ,\ndata: { statements: creations },\n});\n}\nif ( updates ?. length ) {\nawait step ?. sendEvent ( \"update-memories\" , {\nname: \"app/memories.update\" ,\ndata: { updates },\n});\n}\nif ( deletions ?. length ) {\nawait step ?. sendEvent ( \"delete-memories\" , {\nname: \"app/memories.delete\" ,\ndata: { deletions },\n});\n}\nreturn `Scheduled memory operations.` ;\n},\n});\n```\nThis consolidated\n```\nmanage_memories\n```\ntool is a perfect fit for a\n**multi-agent network**\n, where a dedicated \"Memory Updater\" agent has the single, clear responsibility of calling this tool at the end of a conversation - only running once with a tool that can emit many events / memory operations.",
      "char_count": 2349,
      "token_count": 571,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 571,
        "has_context": true
      }
    },
    {
      "index": 13,
      "text": "Memory\nDeterministic vs Non-Deterministic Memory\nThere are two primary patterns for integrating memory into your agents:\n1. **Autonmous Agent w/ Tools (Non-Deterministic):** A single, powerful agent is given memory-related tools and decides for itself when and how to use them based on its system prompt and the conversation. This approach offers maximum flexibility and autonomy.\n2. **Multi-Agent or Lifecycle-based (Deterministic):** The process is broken down into a structured sequence of specialized agents (e.g., one for retrieval, one for responding, one for updating memory), orchestrated by a code-based router. This approach provides predictability and control.\nLet's explore both!",
      "char_count": 691,
      "token_count": 140,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 140,
        "has_context": true
      }
    },
    {
      "index": 14,
      "text": "Memory\nDeterministic vs Non-Deterministic Memory\nPattern 1: Autonomous Agent with Memory Tools\nIn this setup, a single agent is responsible for all tasks. Its system prompt instructs it to follow a\n**recall-reflect-respond**\nprocess. The agent uses its own reasoning (powered by the LLM) to decide which memory tool to use, making the flow non-deterministic.",
      "char_count": 358,
      "token_count": 82,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 82,
        "has_context": true
      }
    },
    {
      "index": 15,
      "text": "Memory\nDeterministic vs Non-Deterministic Memory\nPattern 1: Autonomous Agent with Memory Tools\nExample Agent\nHere is an agent designed to manage its own memory. Note the detailed system prompt guiding its behavior.\nCopy Ask AI\n```\n// From examples/mem0-memory/index.ts\nconst mem0Agent = createAgent ({\nname: \"reflective-mem0-agent\" ,\ndescription:\n\"An agent that can reflect on and manage its memories using mem0.\" ,\nsystem: `\nYou are an assistant with a dynamic, reflective memory. You must actively manage your memories to keep them accurate\nand strategically for search queries to retrieve the most relevant memories related to the user and their query.\n\nOn every user interaction, you MUST follow this process:\n1.  **RECALL**: Use the 'recall_memories' tool with a list of queries relevant to the user's input to get context.\n2.  **ANALYZE & REFLECT**:\n- Compare the user's new statement with the memories you recalled.\n- If there are direct contradictions, you MUST use the 'update_memories' tool to correct the old memories.\n- If old memories are now irrelevant or proven incorrect based on the discussion, you MUST use the 'delete_memories' tool.\n- If this is brand new information that doesn't conflict, you may use the 'create_memories' tool.\n3.  **RESPOND**: Never make mention to the user of any memory operations you have executed.\n` ,\ntools: [\ncreateMemoriesTool ,\nrecallMemoriesTool ,\nupdateMemoriesTool ,\ndeleteMemoriesTool ,\n],\nmodel: openai ({ model: \"gpt-4o\" }),\n});\n```",
      "char_count": 1487,
      "token_count": 344,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 344,
        "has_context": true
      }
    },
    {
      "index": 16,
      "text": "Memory\nDeterministic vs Non-Deterministic Memory\nPattern 1: Autonomous Agent with Memory Tools\nExecution Flow\nThe agent's internal monologue drives the process, deciding which tools to call in sequence.\nPros:\n- **Flexibility & Autonomy:** The agent can handle unforeseen scenarios by reasoning about which tools to use.\n- **Simpler Setup:** Requires only one agent and a comprehensive prompt.\nCons:\n- **Unpredictability:** The agent's behavior can be inconsistent. It might get stuck in loops, call tools in the wrong order, or fail to answer the user's question directly.\n- **Complex Prompting:** The system prompt must be carefully engineered to cover all cases, which can be brittle and hard to maintain.",
      "char_count": 707,
      "token_count": 150,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 150,
        "has_context": true
      }
    },
    {
      "index": 17,
      "text": "Memory\nDeterministic vs Non-Deterministic Memory\nPattern 2: Multi-Agent Network for Memory\nTo address the unpredictability of a single autonomous agent, you can use a deterministic, multi-agent network. The workflow is broken down into a sequence of specialized agents orchestrated by a\n[code-based router](https://agentkit.inngest.com/concepts/routers#code-based-routers-supervised-routing)\n.",
      "char_count": 393,
      "token_count": 83,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 83,
        "has_context": true
      }
    },
    {
      "index": 18,
      "text": "Memory\nDeterministic vs Non-Deterministic Memory\nPattern 2: Multi-Agent Network for Memory\nExample Agents & Router\nThe process is divided into three distinct steps, each handled by a dedicated agent:\n1. **Memory Retrieval Agent** : Its sole job is to use the `recall_memories` tool.\n2. **Personal Assistant Agent** : Has no tools. Its only job is to synthesize the final answer for the user based on the retrieved memories and history.\n3. **Memory Updater Agent** : Reviews the *entire* conversation and uses a `manage_memories` tool to perform all necessary creations, updates, and deletions in one go.\nCopy Ask AI\n```\n// From examples/mem0-memory/multi-agent.ts\n\n// 1. Retrieval Agent\nconst memoryRetrievalAgent = createAgent ({\nname: \"memory-retrieval-agent\" ,\ndescription: \"Retrieves relevant memories based on the user query.\" ,\nsystem: `Your only job is to use the 'recall_memories' tool. ...` ,\ntools: [ recallMemoriesTool ],\n// ...\n});\n\n// 2. Assistant Agent\nconst personalAssistantAgent = createAgent ({\nname: \"personal-assistant-agent\" ,\ndescription: \"A helpful personal assistant that answers user questions.\" ,\nsystem: `Answer the user's question based on the conversation history...` ,\n// No tools\n// ...\n});\n\n// 3. Updater Agent\nconst memoryUpdaterAgent = createAgent ({\nname: \"memory-updater-agent\" ,\ndescription: \"Reflects on the conversation and updates memories.\" ,\nsystem: `Analyze the entire conversation history... you MUST use the 'manage_memories' tool...` ,\ntools: [ manageMemoriesTool ],\n// ...\n});\n\n// The Router enforces the sequence\nconst multiAgentMemoryNetwork = createNetwork ({\nname: \"multi-agent-memory-network\" ,\nagents: [ memoryRetrievalAgent , personalAssistantAgent , memoryUpdaterAgent ],\nrouter : async ({ callCount }) => {\nif ( callCount === 0 ) return memoryRetrievalAgent ;\nif ( callCount === 1 ) return personalAssistantAgent ;\nif ( callCount === 2 ) return memoryUpdaterAgent ;\nreturn undefined ; // Stop the network\n},\n// ...\n});\n```",
      "char_count": 1978,
      "token_count": 468,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 468,
        "has_context": true
      }
    },
    {
      "index": 19,
      "text": "Memory\nDeterministic vs Non-Deterministic Memory\nPattern 2: Multi-Agent Network for Memory\nExecution Flow\nThe router guarantees a predictable, step-by-step execution path.\nPros:\n- **Predictability & Control:** The workflow is explicit and reliable. Each agent has a single, well-defined responsibility.\n- **Maintainability:** It's easier to debug and modify a specific part of the process without affecting the others.\nCons:\n- **More Boilerplate:** Requires defining multiple agents and a router, which can be more verbose for simple use cases.\n- **Less Flexible:** The rigid structure may not adapt as well to unexpected conversational turns compared to an autonomous agent which can determine on its own - when memories should be retrieved.",
      "char_count": 742,
      "token_count": 148,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 148,
        "has_context": true
      }
    },
    {
      "index": 20,
      "text": "Memory\nAdvanced Patterns\nState-Based Memory Retrieval / Routing\nInstead of\n```\ncallCount\n```\n, you can use the network state to create more flexible and explicit routing logic. This is powerful when different agents have different memory needs.\nCopy Ask AI\n```\n// Define your network state interface\ninterface NetworkState {\nmemoriesRetrieved ?: boolean ;\nassistantResponded ?: boolean ;\n}\n\n// Use state-based routing\nconst network = createNetwork < NetworkState >({\n//...\nrouter : async ({ network }) => {\nconst state = network . state . data ;\n\nif ( ! state . memoriesRetrieved ) {\n// In a real implementation, the agent's tool would set this state\n// For example: network.state.data.memoriesRetrieved = true;\nreturn memoryRetrievalAgent ;\n}\nif ( ! state . assistantResponded ) {\nreturn personalAssistantAgent ;\n}\nreturn memoryUpdaterAgent ;\n},\n});\n```",
      "char_count": 854,
      "token_count": 187,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 187,
        "has_context": true
      }
    },
    {
      "index": 21,
      "text": "Memory\nAdvanced Patterns\nLifecycle Integration\nFor a more seamless approach, you can integrate memory operations directly into an agent's or network's lifecycle hooks, avoiding the need for explicit memory tools.\n- **`onStart`** : Fetch memories *before* an agent runs and inject them into the prompt.\n- **`onFinish`** : Analyze the conversation *after* an agent has run and schedule memory updates.\nCopy Ask AI\n```\nconst agentWithLifecycleMemory = createAgent ({\n// ... agent config ...\nlifecycle: {\nasync onStart ({ input , prompt }) {\n// 1. Fetch memories using a custom utility\nconst memories = await recallMemoriesForAgent ( input );\n// 2. Add memories to the prompt for context\nconst memoryMessages = formatMemoriesAsMessages ( memories );\nprompt . push ( ... memoryMessages );\nreturn { prompt , stop: false };\n},\nasync onFinish ({ result , network }) {\n// 3. Analyze the full conversation to decide on memory operations.\nawait analyzeAndManageMemories ( result , network . state . data );\n},\n},\n});\n```",
      "char_count": 1009,
      "token_count": 223,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 223,
        "has_context": true
      }
    },
    {
      "index": 22,
      "text": "Memory\nComplete Example\nCheck out the\n[Mem0 Memory Example](https://github.com/inngest/agent-kit/tree/main/examples/mem0-memory)\nfor a complete implementation featuring:\n- Both single-agent and multi-agent patterns.\n- Asynchronous memory operations with Inngest.\n- A local Qdrant vector store setup with Docker.\n[History Previous](\\concepts\\history)\n[Models Next](\\concepts\\models)\n⌘ I\nAssistant Responses are generated using AI and may contain mistakes.",
      "char_count": 454,
      "token_count": 103,
      "metadata": {
        "title": "##### Get Started",
        "source": "Docs\\agent_kit\\concepts_memory.md",
        "chunk_method": "hybrid",
        "file_path": "Docs\\agent_kit\\concepts_memory.md",
        "file_name": "concepts_memory.md",
        "file_size": 18414,
        "file_format": ".md",
        "mime_type": "text/markdown",
        "sha256_hash": "fcb4851d91f6fc412cb3e0e78ba721ef54f06f02e38c984467421aff74963da5",
        "author": null,
        "created_at": "2025-10-12T23:51:24.036031",
        "modified_at": "2025-10-12T23:51:24.036663",
        "page_count": null,
        "word_count": 2548,
        "extracted_at": "2025-10-13T19:59:27.526690",
        "processing_method": "markdown_docling",
        "custom_metadata": {},
        "total_chunks": 23,
        "token_count": 103,
        "has_context": true
      }
    }
  ]
}